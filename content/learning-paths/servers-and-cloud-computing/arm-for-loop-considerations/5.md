---
title: Loop-carried Dependencies
weight: 5

### FIXED, DO NOT MODIFY
layout: learningpathall
---

## Loop-carried Dependencies

Loop-carried dependencies are computed values that carry over from one iteration to the next, making each iteration dependent on the outcome of the previous one. When trying to vectorise code for Arm SIMD intructions (such as NEON and SVE), the goal is to perform multiple iterations concurrently. However, these dependencies force a strictly sequential execution order, preventing independent, parallel computation across iterations.

Consider the C++ loop below.

```cpp
for (i=0;i<50; i++){
        A[i + 1] = A[i] + c[i];
        B[i + 1] = B[i] + A[i + 1];
}
```

In this loop, an iteration is defined as a single execution of the loop body for a specific index value i. Each iteration computes two new values: one for array A and one for array B. However, two loop-carried dependencies are present that hinder vectorisation.

 - The first dependency is found in the computation of A[i + 1]. Here, the value A[i + 1] relies on the value of A[i] computed in the previous iteration. This creates a sequential chain: you must compute A[i] before you can compute A[i + 1].

 - The second dependency appears in the computation of B[i + 1]. This value depends on B[i] from the previous iteration, and it also relies on A[i + 1], which itself is a product of the previous A value.

 ```cpp
for (i=0; i<1000; i+=1){
    sum = sum + x[i] * y[i];
}
 ```