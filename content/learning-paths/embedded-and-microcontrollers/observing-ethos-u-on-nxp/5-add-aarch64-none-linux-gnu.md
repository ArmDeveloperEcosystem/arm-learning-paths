---
# User change
title: "Add the AArch64 GNU/Linux Toolchain"

weight: 6 # 1 is first, 2 is second, etc.

# Do not modify these elements
layout: "learningpathall"
---

The NXP board uses the [AArch64 GNU/Linux target](https://developer.arm.com/downloads/-/arm-gnu-toolchain-download) (aarch64-none-linux-gnu). The `aarch64-none-linux-gnu` toolchain is required to compile the ExecuTorch runtime files. 

## Add the Toolchain to the examples/arm Directory

1. Make a CMake toolchain file, specifying the NXP board's Linux operating system and AArch64 architecture:

   ```bash
   mkdir examples/arm/aarch64-none-linux-gnu
   touch examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
   nano examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
   ```
   Write the following commands into the `aarch64-none-linux-gnu-gcc.cmake` toolchain file:
   ```cmake
    # Target a Linux AArch64 system (e.g., NXP i.MX93)
    set(CMAKE_SYSTEM_NAME Linux)
    set(CMAKE_SYSTEM_PROCESSOR aarch64)

    # Specify the cross-compilers
    set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
    set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)
    set(CMAKE_ASM_COMPILER aarch64-linux-gnu-gcc)
    set(CMAKE_LINKER aarch64-linux-gnu-ld)

    # Avoid searching for programs on the target system
    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
    set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
   ```

2. Make a custom `CMakeLists.txt` file, specifying the ExecuTorch C++ runtime dependencies:

   ```bash
   touch examples/arm/aarch64-none-linux-gnu/CMakeLists.txt
   nano examples/arm/aarch64-none-linux-gnu/CMakeLists.txt
   ```
   Write the following commands into the custom `CMakeLists.txt` file:
   ```cmake
    # CMakeLists.txt
    cmake_minimum_required(VERSION 3.20)
    project(executor_runner_aarch64_linux_gnu)

    # Tracing and logging
    set(EXECUTORCH_ENABLE_EVENT_TRACER OFF CACHE BOOL "Disable ExecuTorch event tracing")
    set(EXECUTORCH_ENABLE_LOGGING ON CACHE BOOL "Enable ExecuTorch logging")

    # Require C++17
    set(CMAKE_CXX_STANDARD 17)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)

    # Add path to ExecuTorch root directory (adjust as needed)
    set(EXECUTORCH_ROOT "${CMAKE_SOURCE_DIR}/../../../..")

    # Include directories
    include_directories(
    ${EXECUTORCH_ROOT}
    ${EXECUTORCH_ROOT}/runtime
    ${EXECUTORCH_ROOT}/runtime/core
    ${EXECUTORCH_ROOT}/runtime/core/portable_type/c10
    ${EXECUTORCH_ROOT}/runtime/executor
    ${EXECUTORCH_ROOT}/extension
    ${EXECUTORCH_ROOT}/extension/runner_util
    ${EXECUTORCH_ROOT}/third-party/c10
    )

    # Link the static libraries generated by ExecuTorch build
    link_directories(${EXECUTORCH_ROOT}/arm_test/cmake-out)

    # Source file
    add_executable(executor_runner_aarch64_linux_gnu executor_runner_aarch64_linux_gnu.cpp)

    # Use --whole-archive for registration symbols
    set(EXECUTORCH_WHOLE_ARCHIVE_FLAGS
    -Wl,--whole-archive
      portable_kernels
      portable_ops_lib
    -Wl,--no-whole-archive
    )

    # Link libraries
    target_link_libraries(executor_runner_aarch64_linux_gnu
    executorch
    executorch_core
    extension_runner_util
    ${EXECUTORCH_WHOLE_ARCHIVE_FLAGS}
    )

    # Logging support
    add_definitions(-DEXECUTORCH_ENABLE_LOGGING)

    # Optional: print final link command
    set(CMAKE_VERBOSE_MAKEFILE ON)
   ```

3. Make a custom `executor_runner_aarch64_linux_gnu.cpp` file, specifying the ExecuTorch C++ runtime dependencies:

   ```bash
   touch examples/arm/aarch64-none-linux-gnu/executor_runner_aarch64_linux_gnu.cpp
   nano examples/arm/aarch64-none-linux-gnu/executor_runner_aarch64_linux_gnu.cpp
   ```
   Write the following code into the custom `executor_runner_aarch64_linux_gnu.cpp` file:
   ```cpp
   // executor_runner.cpp
   #include <executorch/runtime/platform/log.h>
   #include <executorch/runtime/platform/platform.h>
   #include <executorch/runtime/platform/runtime.h>
   #include <executorch/runtime/executor/program.h>
   #include <executorch/extension/runner_util/inputs.h>

   #include <iostream>
   #include <vector>
   #include <memory>
   #include <fstream>
   #include <iterator>

   using namespace executorch::runtime;

   int main(int argc, const char* argv[]) {
   if (argc != 2) {
      std::cerr << "Usage: " << argv[0] << " <model.pte>" << std::endl;
      return 1;
   }

   const char* model_path = argv[1];
   std::ifstream file(model_path, std::ios::binary);
   if (!file) {
      std::cerr << "Failed to open model file: " << model_path << std::endl;
      return 1;
   }

   std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
   BufferDataLoader loader(buffer.data(), buffer.size());

   auto program_result = Program::load(&loader);
   if (!program_result.ok()) {
      std::cerr << "Failed to load program: " << (int)program_result.error() << std::endl;
      return 1;
   }

   auto& program = program_result.get();
   auto method_name_result = program.get_method_name(0);
   if (!method_name_result.ok()) {
      std::cerr << "Failed to get method name." << std::endl;
      return 1;
   }

   const char* method_name = method_name_result.get();
   auto method_result = program.load_method(method_name);
   if (!method_result.ok()) {
      std::cerr << "Failed to load method: " << (int)method_result.error() << std::endl;
      return 1;
   }

   auto& method = method_result.get();
   if (method.execute() != Error::Ok) {
      std::cerr << "Execution failed." << std::endl;
      return 1;
   }

   std::cout << "Model executed successfully." << std::endl;
   return 0;
   }
   ```

## Add the Toolchain to build_executorch.sh

1. Add the `aarch64-none-linux-gnu` toolchain to `backends/arm/scripts/build_executorch.sh`:
   - Open file `build_executorch.sh`:
     
     ```bash
     nano backends/arm/scripts/build_executorch.sh
     ```

   - Find the following code block (approximately [lines 95-108](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/backends/arm/scripts/build_executorch.sh#L95-L108)):
   
     ```bash
     # Build
     cmake                                                 \
         -DCMAKE_INSTALL_PREFIX=${et_build_dir}            \
         -DCMAKE_BUILD_TYPE=${build_type}                  \
         -DCMAKE_TOOLCHAIN_FILE="${toolchain_cmake}"       \
         -DEXECUTORCH_BUILD_EXECUTOR_RUNNER=OFF            \
         -DEXECUTORCH_BUILD_ARM_BAREMETAL=ON               \
         -DEXECUTORCH_BUILD_KERNELS_QUANTIZED=ON           \
         -DEXECUTORCH_BUILD_EXTENSION_RUNNER_UTIL=ON       \
         -DEXECUTORCH_BUILD_CORTEX_M=ON                    \
         -DEXECUTORCH_ENABLE_LOGGING=ON                    \
         ${build_devtools_flags}                           \
         ${build_with_etdump_flags}                        \
         -B"${et_build_dir}"                               \
         "${et_root_dir}"
     ```

     and replace it with this code block:
   
     ```bash
     # Build
     baremetal_flags=""
     if [[ ${toolchain} == "arm-none-eabi-gcc" ]] || [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then
         baremetal_flags="-DEXECUTORCH_BUILD_ARM_BAREMETAL=ON"
     else
         baremetal_flags="-DEXECUTORCH_BUILD_ARM_BAREMETAL=OFF"
     fi

     cmake                                                 \
         -DCMAKE_INSTALL_PREFIX=${et_build_dir}            \
         -DCMAKE_BUILD_TYPE=${build_type}                  \
         -DCMAKE_TOOLCHAIN_FILE="${toolchain_cmake}"       \
         -DEXECUTORCH_BUILD_EXECUTOR_RUNNER=OFF            \
         -DEXECUTORCH_BUILD_KERNELS_QUANTIZED=ON           \
         -DEXECUTORCH_BUILD_EXTENSION_RUNNER_UTIL=ON       \
         -DEXECUTORCH_BUILD_CORTEX_M=ON                    \
         -DEXECUTORCH_ENABLE_LOGGING=ON                    \
         ${baremetal_flags}                                \
         ${build_devtools_flags}                           \
         ${build_with_etdump_flags}                        \
         -B"${et_build_dir}"                               \
         "${et_root_dir}"
     ```

   - Find the following two lines (approximately [lines 51-52](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/backends/arm/scripts/build_executorch.sh#L51-L52)):
   
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     ```
     and add the `aarch64-none-linux-gnu` toolchain below it, as follows:
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     elif [[ ${toolchain} == "aarch64-none-linux-gnu-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
     ```

## Add the Toolchain to setup.sh

1. Add the `aarch64-none-linux-gnu` toolchain to `examples/arm/setup.sh`:
   - Open file `setup.sh`:
     ```bash { output_lines = "1" }
     # vim is another file editor that you can use instead of nano
     apt install nano
     nano examples/arm/setup.sh
     ```
   - Find the following code block (approximately [lines 295-300](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/examples/arm/setup.sh#L295-L300)):
   
     ```bash
     elif [[ "${OS}" == "Linux" ]]; then
	      if [[ "${target_toolchain}" == "zephyr" ]]; then
	          # eventually, this can be support by downloading the the toolchain from 
		       # "https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.2/toolchain_linux-aarch64_arm-zephyr-eabi.tar.xz"
		       # but for now, we error if user tries to specify this
             echo "[main] Error: currently target_toolchain zephyr is only support for x86-64 Linux host systems!"; exit 1;
     ```
     and add the `aarch64-none-linux-gnu` toolchain below it, as follows:
     ```bash
     elif [[ "${OS}" == "Linux" ]]; then
         if [[ "${target_toolchain}" == "zephyr" ]]; then
             # eventually, this can be support by downloading the the toolchain from 
             # "https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.17.2/toolchain_linux-aarch64_arm-zephyr-eabi.tar.xz"
             # but for now, we error if user tries to specify this
             echo "[main] Error: currently target_toolchain zephyr is only support for x86-64 Linux host systems!"; exit 1;
         elif [[ "${target_toolchain}" == "aarch64-none-linux-gnu" ]]; then
             toolchain_url="https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/arm-gnu-toolchain-14.3.rel1-aarch64-aarch64-none-linux-gnu.tar.xz"
             toolchain_dir="arm-gnu-toolchain-14.3.rel1-aarch64-aarch64-none-linux-gnu"
             toolchain_md5_checksum="af75c27193025c4e09812f271f2f9075"
     ```

## Add the Toolchain to run.sh

1. Add the `aarch64-none-linux-gnu` toolchain to `examples/arm/run.sh`:
   - Open file `run.sh`:
     
     ```bash
     nano examples/arm/run.sh
     ```

   - Find the following two lines (approximately [lines 101-102](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/examples/arm/run.sh#L101-L102)):
   
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     ```
     and add the `aarch64-none-linux-gnu` toolchain below it, as follows:
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     elif [[ ${toolchain} == "aarch64-none-linux-gnu-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
     ```

## Add the Toolchain to build_portable_kernels.sh

1. Add the `aarch64-none-linux-gnu` toolchain to `backends/arm/scripts/build_portable_kernels.sh`:
   - Open file `build_portable_kernels.sh`:
     
     ```bash
     nano backends/arm/scripts/build_portable_kernels.sh
     ```

   - Find the following code block (approximately [lines 49-50](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/backends/arm/scripts/build_portable_kernels.sh#L49-L50)):

     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     ```
     and add the `aarch64-none-linux-gnu` toolchain below it, as follows:
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     elif [[ ${toolchain} == "aarch64-none-linux-gnu-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
     ```

## Add the Toolchain to build_executor_runner.sh

1. Add the `aarch64-none-linux-gnu` toolchain to `backends/arm/scripts/build_executor_runner.sh`:
   - Open file `build_executor_runner.sh`:
     
     ```bash
     nano backends/arm/scripts/build_executor_runner.sh
     ```

   - Find the following code block (approximately [lines 75-76](https://github.com/pytorch/executorch/blob/2bd96df8de07bc86f2966a559e3d6c80fc324896/backends/arm/scripts/build_executor_runner.sh#L75-L76)):

     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     ```
     and add the `aarch64-none-linux-gnu` toolchain below it, as follows:
     ```bash
     elif [[ ${toolchain} == "arm-zephyr-eabi-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/zephyr/x86_64-linux-arm-zephyr-eabi-gcc.cmake
     elif [[ ${toolchain} == "aarch64-none-linux-gnu-gcc" ]]; then 
         toolchain_cmake=${et_root_dir}/examples/arm/aarch64-none-linux-gnu/aarch64-none-linux-gnu-gcc.cmake
     ```