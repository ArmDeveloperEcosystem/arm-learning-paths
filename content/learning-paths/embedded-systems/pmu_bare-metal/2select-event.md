---
title: Select PMU events for profiling
weight: 3

### FIXED, DO NOT MODIFY
layout: learningpathall
---
Now you can consider what PMU events to select for profiling. Before that, you need to acquire supporting PMU events for the Armv8-A CPU on which the firmware runs. You can refer to the CPU Technical Reference Manual (TRM) for the PMU events.

In the PMU library, you can also use a Python script named `jevents.py`.

## Acquire supporting PMU events for the specified Armv8-A CPU

The github repository [Machine-readable data](https://github.com/ARM-software/data/tree/master) maintains PMU events supported by each Arm CPU. It uses JSON format to store information like event mnemonic and event number of th PMU events. Also, the information is consistent with that in the CPU TRM.

The Python script named `jevents.py` in the PMU library is to convert the JSON format to C format, and generate the file named `armv8_pmuv3_events.c`.

First, use the following command to list all the names of the supporting CPUs for converting.

``` bash
python3 jevents.py --list
```

You may get the following output.

``` bash
arm1136jf-s,arm1176jzf-s,common_armv7,common_armv8,common_armv9,cortex-a15,cortex-a17,cortex-a32,cortex-a34,
cortex-a35,cortex-a5,cortex-a510,cortex-a53,cortex-a55,cortex-a57,cortex-a65,cortex-a65ae,cortex-a7,cortex-a710,
cortex-a715,cortex-a72,cortex-a73,cortex-a75,cortex-a76,cortex-a76ae,cortex-a77,cortex-a78,cortex-a78c,cortex-a8,
cortex-a9,cortex-r4,cortex-r5,cortex-r52,cortex-r7,cortex-r8,cortex-r82,cortex-x1,cortex-x1c,cortex-x2,cortex-x3,
neoverse-e1,neoverse-n1,neoverse-n2,neoverse-v1,neoverse-v2,rainier 
```

Then, use the following command by specifying the name of the CPU for converting. This command will generate the file named `armv8_pmuv3_events.c`. It contains two types of arrays: one is for the supporting PMU events of the specified CPU PMU. The onther is for the selected PMU events for profiling.

``` bash
python3 jevents.py --cpu <cpu name>
```

An example of `armv8_pmuv3_events.c` file generated by `jevents.py` is as follows. We specify the cpu name as `cortex-a53`. The array named `pmu_events_map` contains all the supporting PMU events for cortex-a53. It is the same with the cortex-a53 TRM. You can select the PMU events from it, and put the selected ones into the array named `evt_select`.

```c
#include "armv8_pmuv3_events.h"

/* Selected PMU Events Table */
struct pmu_event_selected evt_select[] = {
    //{ .event.name = "BR_PRED", .event.number = 0x12 },
    /* Assign event number -1 to the event counting by the cycle counter and place it at the end of the table */
    { .event.name = "CYCLES", .event.number = -1 } 
};

/* PMU Events Mapping Table */
const struct pmu_event pmu_events_map[] = {
    { .name = "SW_INCR", .number = 0x0 },
    { .name = "L1I_CACHE_REFILL", .number = 0x1 },
    { .name = "L1I_TLB_REFILL", .number = 0x2 },
    { .name = "L1D_CACHE_REFILL", .number = 0x3 },
    { .name = "L1D_CACHE", .number = 0x4 },
    { .name = "L1D_TLB_REFILL", .number = 0x5 },
    { .name = "LD_RETIRED", .number = 0x6 },
    { .name = "ST_RETIRED", .number = 0x7 },
    { .name = "INST_RETIRED", .number = 0x8 },
    { .name = "EXC_TAKEN", .number = 0x9 },
    { .name = "EXC_RETURN", .number = 0xa },
    { .name = "CID_WRITE_RETIRED", .number = 0xb },
    { .name = "PC_WRITE_RETIRED", .number = 0xc },
    { .name = "BR_IMMED_RETIRED", .number = 0xd },
    { .name = "BR_RETURN_RETIRED", .number = 0xe },
    { .name = "UNALIGNED_LDST_RETIRED", .number = 0xf },
    { .name = "BR_MIS_PRED", .number = 0x10 },
    { .name = "CPU_CYCLES", .number = 0x11 },
    { .name = "BR_PRED", .number = 0x12 },
    { .name = "MEM_ACCESS", .number = 0x13 },
    { .name = "L1I_CACHE", .number = 0x14 },
    { .name = "L1D_CACHE_WB", .number = 0x15 },
    { .name = "L2D_CACHE", .number = 0x16 },
    { .name = "L2D_CACHE_REFILL", .number = 0x17 },
    { .name = "L2D_CACHE_WB", .number = 0x18 },
    { .name = "BUS_ACCESS", .number = 0x19 },
    { .name = "MEMORY_ERROR", .number = 0x1a },
    { .name = "BUS_CYCLES", .number = 0x1d },
    { .name = "CHAIN", .number = 0x1e },
    { .name = "BUS_ACCESS_RD", .number = 0x60 },
    { .name = "BUS_ACCESS_WR", .number = 0x61 },
    { .name = "BR_INDIRECT_SPEC", .number = 0x7a },
    { .name = "EXC_IRQ", .number = 0x86 },
    { .name = "EXC_FIQ", .number = 0x87 },
    { .name = "0xc0", .number = 0xc0 },
    { .name = "0xc1", .number = 0xc1 },
    { .name = "0xc2", .number = 0xc2 },
    { .name = "0xc3", .number = 0xc3 },
    { .name = "0xc4", .number = 0xc4 },
    { .name = "0xc5", .number = 0xc5 },
    { .name = "0xc6", .number = 0xc6 },
    { .name = "0xc7", .number = 0xc7 },
    { .name = "0xc8", .number = 0xc8 },
    { .name = "0xc9", .number = 0xc9 },
    { .name = "0xca", .number = 0xca },
    { .name = "0xcb", .number = 0xcb },
    { .name = "0xcc", .number = 0xcc },
    { .name = "0xd0", .number = 0xd0 },
    { .name = "0xd1", .number = 0xd1 },
    { .name = "0xd2", .number = 0xd2 },
    { .name = "0xe0", .number = 0xe0 },
    { .name = "0xe1", .number = 0xe1 },
    { .name = "0xe2", .number = 0xe2 },
    { .name = "0xe3", .number = 0xe3 },
    { .name = "0xe4", .number = 0xe4 },
    { .name = "0xe5", .number = 0xe5 },
    { .name = "0xe6", .number = 0xe6 },
    { .name = "0xe7", .number = 0xe7 },
    { .name = "0xe8", .number = 0xe8 },
};
```

## Select PMU events for profiling

In the initial profiling, normally a wide range of PMU events are selected to get a comprehensive understanding of the code to profile.

For Armv8-A CPUs, the available event counters per CPU are limited. You can refer to the CPU TRM for the number. If the required number of PMU events exceeds the available counters, you can take following method.

1. Divide all PMU events to select into groups. In each group, the number of the events does not exceed the available counters of the PMU.
2. Create multiple `pmu_event_selected` structure arrays and put each group into one array.
3. Profile the same code multiple times, select one array at a time, and repeat the process until all events are measured. 

For example, we create two `pmu_event_selected` structure arrays named `evt_select_cache` and `evt_select_wlc` in the `armv8_pmuv3_events.c` file. For cortex-a53, one cycle counter and six event counters are available. The number of PMU events in each array does not exceed it. Also, within each array, the PMU events are related so that the profiling data will be comparable.

We will use this two arrays for the following profiling examples.

``` c
/* PMU events for data access */
struct pmu_event_selected evt_select_cache[] = {
    { .event.name = "L1D_TLB_REFILL", .event.number = 0x5 },
    { .event.name = "L1D_CACHE_REFILL", .event.number = 0x3 },
    { .event.name = "L1D_CACHE", .event.number = 0x4 },
    { .event.name = "L2D_CACHE_REFILL", .event.number = 0x17 },
    { .event.name = "L2D_CACHE", .event.number = 0x16 },
	/* Assign event number -1 to the event counting by the cycle counter and place it at the end of the table */
    { .event.name = "CYCLES", .event.number = -1 } 
};

/* PMU events for workload characterization */
struct pmu_event_selected evt_select_wlc[] = {
    { .event.name = "LD_RETIRED", .event.number = 0x6 },
    { .event.name = "ST_RETIRED", .event.number = 0x7 },
    { .event.name = "MEM_ACCESS", .event.number = 0x4 },
    { .event.name = "BR_IMMED_RETIRED", .event.number = 0xd },
    { .event.name = "BR_RETURN_RETIRED", .event.number = 0xe },
	/* Assign event number -1 to the event counting by the cycle counter and place it at the end of the table */
    { .event.name = "CYCLES", .event.number = -1 } 
};
```

{{% notice Note %}}
In each `pmu_event_selected` structure array, put the cycle counting by the cycle counter in the last with event number of -1 and event name `CYCLES`. This is used to distinguish `CPU_CYCLES` event with the event number of 0x11.
{{% /notice %}}